---
title: "Why do we need modules?"
description: "Exploring the why behind JavaScript module systems."
createdAt: 06-01-2025
image: "../assets/why-do-we-need-modules.png"
draft: true
tags:
  - javascript
---


Modules in JavaScript, a topic I’ve never fully understood, but I always pretended to. CommonJS and ES modules sound like buzzwords I’ve heard in tutorials. The only thing I’m clear about is that ES modules are the modern standard and should be preferred over CommonJS. But why? What problem do module systems solve in the first place?

First of all, what even is a module?

Modules make it much easier to break down large and complex codebases into smaller and simpler parts. Without modules, all logic lives together, and the result is a single JavaScript file containing all of an application’s code.

That sounds difficult to manage. Maybe we can manage writing everything in one file for a simple to-do list side project. But for larger codebases? No way.

That explains the need for modules. But why not just break down the logic into separate JavaScript files and use multiple script tags? That should help with separation, right? Why do we need something fancy like CommonJS or ES modules?

It is doable, but there are some big problems. Let’s try to uncover those by looking at what happens without modules.

When we split code into different scripts that aren’t modules, the scripts don’t get isolated scopes. They share the same global scope.

```javascript
// message.js
const message = 'Hello, world!';
```

```javascript
// main.js
console.log(message);
```

```html
<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Demo</title>
</head>
<body>
    <script src="./message.js"></script>
    <script src="./main.js"></script>
</body>
</html>
```

Here, “Hello, world!” gets printed to the console, even though `message` is declared in a completely separate script.

Everything is globally available to everyone, but this doesn’t seem like a good idea for obvious reasons.

Ideally, we’d want to develop in isolation and only share what we explicitly choose to share with other scripts.

We can "create" isolation using IIFEs (Immediately Invoked Function Expressions) to wrap each script’s contents.

```javascript
// message.js
(function () {
  const message = 'Hello, world!';
})();
```

```javascript
// main.js
(function () {
  console.log(message);
})();
```

This gives us the outcome we wanted - trying to access `message` outside its script results in a ReferenceError.

But now we have the opposite problem. Everything is private, but we still want to share some things for reuse, right?

Without the ability to define exports like we do in modules, managing this is tricky. One way is by assigning the values we want to “export” to the `window` object *(or `global` object in Node.js)*.

```javascript
// message.js
(function () {
  const localMessage = 'Hello, world!';
  window.message = localMessage;
})();
```

```javascript
// main.js
(function () {
  console.log(window.message);
})();
```

This is a viable option. Libraries like jQuery used to do the same thing. We can maintain an isolated scope locally and explicitly define what we want to expose to the global scope.

This isn’t optimal, though. How do we handle name collisions on the global object? How do we know who is exporting what? More importantly, what happens if the load order of the scripts gets messed up and `main.js` is loaded before `message.js`?

```html
<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Demo</title>
</head>
<body>
    <script src="./main.js"></script>
    <script src="./message.js"></script>
</body>
</html>
```

This results in `undefined` being printed to the console, because `window.message` is not yet assigned when main.js is executed.

Whenever a script needs to reuse some code present in another script, the load order of those scripts matters.

In our simple example, we only use two scripts, so it may not seem like a big deal. But imagine thousands of scripts like these; it will get very difficult, very quickly, to manage the whole thing.

Managing dependencies with a module-less approach like this seems harder than it needs to be.

As no surprise, these are the exact challenges developers faced without any standardised module system in JavaScript before ES modules. 

As a result, the community came up with custom solutions like *CommonJS*, *AMD*, and *UMD*, each trying to solve the same problem in different environments.

Eventually, in 2015, with ES6, JavaScript standardised modules natively with ES modules, which are currently supported in both browser and Node environments.

ES modules make things much easier, we get isolated scopes per module, we don’t have to worry about how dependencies are loaded - just specify `type="module"` to enable ES modules syntax and the browser takes care of everything for you!
